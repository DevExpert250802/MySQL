Longest Common Subsequence



// Recursion


#include <bits/stdc++.h>

int f(int i,int j,string&s,string&t){
   if(i<0 || j<0) return 0;

	if(s[i]==t[j]) return 1+f(i-1,j-1,s,t);

	return 0+max( f(i-1,j,s,t),f(i,j-1,s,t));
}

int lcs(string s, string t){
int n= s.length();
int m= t.length();
return  f(n-1,m-1,s,t);
}






// Memorization



#include <bits/stdc++.h>

int f(int i,int j,string&s,string&t,vector<vector<int>>&dp){
   if(i<0 || j<0) return 0;
    if(dp[i][j] != -1) return dp[i][j];
	if(s[i]==t[j]) return dp[i][j] =1+f(i-1,j-1,s,t,dp);

	return dp[i][j] =0+max( f(i-1,j,s,t,dp),f(i,j-1,s,t,dp));
}

int lcs(string s, string t){
int n= s.length();
int m= t.length();
vector<vector<int>>dp(n,vector<int>(m,-1));
return  f(n-1,m-1,s,t,dp);
}



// shifting of index 



int f(int i,int j,string&s,string&t,vector<vector<int>>&dp){
   if(i==0 || j==0) return 0;
    if(dp[i][j] != -1) return dp[i][j];
	if(s[i-1]==t[j-1]) return dp[i][j] =1+f(i-1,j-1,s,t,dp);

	return dp[i][j] =0+max( f(i-1,j,s,t,dp),f(i,j-1,s,t,dp));
}

int lcs(string s, string t){
int n= s.length();
int m= t.length();
vector<vector<int>>dp(n+1,vector<int>(m+1,-1));
return  f(n,m,s,t,dp);
}







// Tabulation



int lcs(string s, string t){
int n= s.length();
int m= t.length();
vector<vector<int>>dp(n+1,vector<int>(m+1,0));

for(int j=0;j<=m;j++) dp[0][j]=0;
for(int i=0;i<=n;i++) dp[i][0]=0;

for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		if(s[i-1]==t[j-1])  dp[i][j] =1+dp[i-1][j-1];
	   else dp[i][j] =0+max( dp[i-1][j] , dp[i][j-1]);
	}
}
	return dp[n][m];
}







// Space optimization



int lcs(string s, string t){
int n= s.length();
int m= t.length();
vector<int>prev(m+1,0),cur(m+1,0);

for(int j=0;j<=m;j++) prev[j]=0;

for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		if(s[i-1]==t[j-1])  cur[j] =1+prev[j-1];
	   else cur[j] =0+max( prev[j] , cur[j-1]);
	}
	prev=cur;
}
	return prev[m];
}





____________________________________________________________________________________________________________________________________________________________________________________________


Print Longest Common Subsequence




// Tabulation



#include <bits/stdc++.h>>
string findLCS(int n, int m, string &s, string &t) {
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s[i - 1] == t[j - 1])
                dp[i][j] = 1 + dp[i - 1][j - 1];
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }

    int len = dp[n][m];
    string ans = "";
    for (int i = 0; i < len; i++) {
        ans += '$';
    }

    int i = n, j = m;
    int ind = len - 1;
    while (i > 0 && j > 0) {
        if (s[i - 1] == t[j - 1]) {
            ans[ind] = s[i - 1];
            ind--, i--,j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    return ans;
}


TC = O(n*m) | SC = O(n*m)



_____________________________________________________________________________________________________________________________________________________________________________________________


Longest Common Substring





#include <bits/stdc++.h>
int lcs(string &s, string &t){
	int n=s.size();
	int m=t.size();
  int ans=0;
	vector<vector<int>>dp(n+1,vector<int>(m+1,0));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
      if (s[i - 1] == t[j - 1]) {
        dp[i][j] = 1 + dp[i - 1][j - 1];
        ans = max(ans, dp[i][j]);
      } else dp[i][j] = 0;
    }
  }
	return ans;		 
}






TC = O(n*m) | SC = O(n*m)






#include <bits/stdc++.h>
int lcs(string &s, string &t){
	int n=s.size();
	int m=t.size();
  int ans=0;
	vector<int>prev(m+1,0),cur(m+1,0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
      if (s[i - 1] == t[j - 1]) {
        cur[j] = 1 + prev[j - 1];
        ans = max(ans, cur[j]);
      } else cur[j] = 0;
    }
    prev=cur;
  }
	return ans;		 
}



TC = O(n*m) | SC = O(m)




_____________________________________________________________________________________________________________________________________________________________________________________________


Longest Palindromic Subsequence




#include <bits/stdc++.h> 
int lcs(string s, string t){
int n= s.length();
int m= t.length();
vector<vector<int>>dp(n+1,vector<int>(m+1,0));

for(int j=0;j<=m;j++) dp[0][j]=0;
for(int i=0;i<=n;i++) dp[i][0]=0;

for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
	if(s[i-1]==t[j-1])  dp[i][j] =1+dp[i-1][j-1];
	 else dp[i][j] =0+max( dp[i-1][j] , dp[i][j-1]);
	}
    }
    return dp[n][m];
}
int longestPalindromeSubsequence(string s){
    string t =s;
    reverse(s.begin(),s.end());
    return lcs(s,t);
}









#include <bits/stdc++.h> 
int lcs(string &s, string &t){
	int n=s.size();
	int m=t.size();
    vector<int>prev(m+1,0),cur(m+1,0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(s[i-1]==t[j-1]) cur[j] =1 +prev[j-1];
			else cur[j]=max(prev[j],cur[j-1]);
		}
        prev=cur;
	}
	return prev[m];		 
}
int longestPalindromeSubsequence(string s){
    string t =s;
    reverse(s.begin(),s.end());
    return lcs(s,t);
}






____________________________________________________________________________________________________________________________________________________________________________________________




Minimum insertions to make a string palindrome









#include <bits/stdc++.h> 
int lcs(string &s, string &t){
   int n=s.size();
   int m=t.size();
    vector<int>prev(m+1,0),cur(m+1,0);
	for(int i=1;i<=n;i++){
	   for(int j=1;j<=m;j++){
	      if(s[i-1]==t[j-1]) cur[j] =1 +prev[j-1];
	      else cur[j]=max(prev[j],cur[j-1]);
	   }
           prev=cur;
	}
    return prev[m];		 
   }
int longestPalindromeSubsequence(string s){
    string t =s;
    reverse(s.begin(),s.end());
    return lcs(s,t);
 }
int minimumInsertions(string &str){
 return str.size()-longestPalindromeSubsequence(str);
}


_____________________________________________________________________________________________________________________________________________________________________________________________






Minimum Insertions/Deletions to Convert String





int lcs(string &s, string &t){
   int n=s.size();
   int m=t.size();
    vector<int>prev(m+1,0),cur(m+1,0);
	for(int i=1;i<=n;i++){
	   for(int j=1;j<=m;j++){
	      if(s[i-1]==t[j-1]) cur[j] =1 +prev[j-1];
	      else cur[j]=max(prev[j],cur[j-1]);
	   }
           prev=cur;
	}
    return prev[m];		 
   }


int canYouMake(string &s1, string &s2){
    int Number_of_Deletion  = s1.size()-lcs(s1,s2);
    int  Number_of_Insertion = s2.size()-lcs(s1,s2);
    int Number_of_Operation=Number_of_Deletion+Number_of_Insertion;
    return Number_of_Operation;


}







____________________________________________________________________________________________________________________________________________________________________________________________



Shortest Common Supersequence  ( length )



int lcs(string &s, string &t){
   int n=s.size();
   int m=t.size();
    vector<int>prev(m+1,0),cur(m+1,0);
	for(int i=1;i<=n;i++){
	   for(int j=1;j<=m;j++){
	      if(s[i-1]==t[j-1]) cur[j] =1 +prev[j-1];
	      else cur[j]=max(prev[j],cur[j-1]);
	   }
           prev=cur;
	}
    return prev[m];		 
   }

int lengthofSupersequence(string &s1, string &s2){

    int n  = s1.size();
    int m  = s2.size();
    return n + m -lcs(s1,s2);

}

_____________________________________________________________________________________________________________________________________________________________________________________________



Shortest Common Supersequence 








#include <bits/stdc++.h> 
string shortestSupersequence(string s, string t){
int n= s.length();
int m= t.length();
vector<vector<int>>dp(n+1,vector<int>(m+1,0));

for(int j=0;j<=m;j++) dp[0][j]=0;
for(int i=0;i<=n;i++) dp[i][0]=0;

for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		if(s[i-1]==t[j-1])  dp[i][j] =1+dp[i-1][j-1];
	   else dp[i][j] =0+max( dp[i-1][j] , dp[i][j-1]);
	}
}
  string ans = "";
   int i=n , j=m;
    while(i > 0 &&  j > 0){
        if(s[i-1] == t[j-1]) {
			ans+=s[i-1];
			i--,j--;
		}
		else if (dp[i-1][j]>dp[i][j-1]){
			ans+=s[i-1]; 
			i--;
		}
		else{
			ans+=t[j-1];
			j--;
		}
	}
	while(i>0) {
	   ans+=s[i-1];
	   i--;
	}
	while(j>0) {
	   ans+=t[j-1];
	   j--;
	}
    reverse(ans.begin() , ans.end());
        return ans;
}






_____________________________________________________________________________________________________________________________________________________________________________________________

 Distinct Subsequences




int f(int i,int j,string&s1,string&s2){
	if(j<0) return 1;
	if(i<0) return 0;
	if(s1[i]==s2[j]) return f(i-1,j,s1,s2) + f(i-1,j-1,s1,s2);
        else
	return f(i-1,j,s1,s2);
}
int distinctSubsequences(string &str, string &sub){
	int n=str.size();
	int m=sub.size();
	return f(n-1,m-1,str,sub);

}




int mod =1e9+7;
int f (int i,int j,string &s1,string& s2,vector<vector<int>>&dp){
	if(j<0) return 1;
	if(i<0) return 0;
	if(dp[i][j] != -1) return dp[i][j];
	if(s1[i]==s2[j]){
	 return dp[i][j] = ( f(i-1,j,s1,s2,dp) + f(i-1,j-1,s1,s2,dp) )%mod;
	}
	return dp[i][j] = f(i-1,j,s1,s2,dp)%mod;
}
int distinctSubsequences(string &str, string &sub){
	int n=str.size();
	int m=sub.size();
	vector<vector<int>>dp(n,vector<int>(m,-1));
	return f(n-1,m-1,str,sub,dp);

}





int mod =1e9+7;
int f (int i,int j,string &s1,string& s2,vector<vector<int>>&dp){
	if(j==0) return 1;
	if(i==0) return 0;
	if(dp[i][j] != -1) return dp[i][j];
	if(s1[i-1]==s2[j-1]){
	 return dp[i][j] = ( f(i-1,j,s1,s2,dp) + f(i-1,j-1,s1,s2,dp) )%mod;
	}
	return dp[i][j] = f(i-1,j,s1,s2,dp)%mod;
}
int distinctSubsequences(string &str, string &sub){
	int n=str.size();
	int m=sub.size();
	vector<vector<int>>dp(n+1,vector<int>(m+1,-1));
	return f(n,m,str,sub,dp);
}





int mod =1e9+7;
int distinctSubsequences(string &s1, string &s2){
	int n=s1.size();
	int m=s2.size();
	vector<vector<int>>dp(n+1,vector<int>(m+1,0));
	for(int i=0;i<=n;i++) dp[i][0]=1;
	for(int j=1;j<=m;j++) dp[0][j]=0;

	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
		  if(s1[i-1]==s2[j-1]){
	        dp[i][j] = (dp[i-1][j] + dp[i-1][j-1] )%mod;
	        }
	      else dp[i][j] = dp[i-1][j]%mod;
		}
	}
	return dp[n][m];
}









int mod =1e9+7;
int distinctSubsequences(string &s1, string &s2){
	int n=s1.size();
	int m=s2.size();
	vector<int>prev(m+1,0),cur(m+1,0);
	prev[0]= cur[0]=1;

	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
		  if(s1[i-1]==s2[j-1]){
	        cur[j] = (prev[j] + prev[j-1] )%mod;
	        }
	      else cur[j] = prev[j]%mod;
		}
		prev=cur;
	}
	return prev[m];
}








int mod =1e9+7;
int distinctSubsequences(string &s1, string &s2){
	int n=s1.size();
	int m=s2.size();
	vector<int>prev(m+1,0);
	prev[0]=1;

	for(int i=1;i<=n;i++){
		for(int j=m;j>=1;j--){
		  if(s1[i-1]==s2[j-1]){
	        prev[j] = (prev[j] + prev[j-1] )%mod;
	        }
	      else prev[j] = prev[j]%mod;
		}
	}
	return prev[m];
}



_____________________________________________________________________________________________________________________________________________________________________________________________




 Edit Distance




Problem statement
You are given two strings 'S' and 'T' of lengths 'N' and 'M' respectively. Find the "Edit Distance" between the strings.

Edit Distance of two strings is the minimum number of steps required to make one string equal to the other. In order to do so, you can perform the following three operations:

1. Delete a character
2. Replace a character with another one
3. Insert a character









#include <bits/stdc++.h>
int f(string& s1, string& s2, int i, int j) {
    if (i < 0) return j + 1;
    if (j < 0)return i + 1;
    if (s1[i] == s2[j])
        return  f(s1, s2, i-1, j-1);
    else  //  Delete    Replace    Insert 
    return 1 + min({f(s1, s2,i-1,j),f(s1, s2,i -1,j-1),f(s1, s2, i, j - 1)});
}

int editDistance(string& S1, string& S2) {
    int n = S1.size();
    int m = S2.size();
    return f(S1, S2, n - 1, m - 1);
}







#include <bits/stdc++.h>
int f(string& s1, string& s2, int i, int j,vector<vector<int>>&dp) {
    if (i < 0) return j + 1;
    if (j < 0)return i + 1;
    if(dp[i][j]!=-1)return dp[i][j];
    if (s1[i] == s2[j])
        return  dp[i][j]= f(s1, s2, i-1, j-1,dp);
    else  //  Delete    Replace    Insert 
    return dp[i][j] = 1 + min({f(s1, s2,i-1,j,dp),f(s1, s2,i -1,j-1,dp),f(s1, s2, i, j - 1,dp)});
}

int editDistance(string& S1, string& S2) {
    int n = S1.size();
    int m = S2.size();
    vector<vector<int>>dp(n,vector<int>(m,-1));
    return f(S1, S2, n-1, m-1,dp);
}







#include <bits/stdc++.h>
int f(string& s1, string& s2, int i, int j,vector<vector<int>>&dp) {
    if (i == 0) return j ;
    if (j == 0)return i ;
    if(dp[i][j]!=-1)return dp[i][j];
    if (s1[i-1] == s2[j-1])
        return  dp[i][j]= f(s1, s2, i-1, j-1,dp);
    else  //  Delete    Replace    Insert 
    return dp[i][j] = 1 + min({f(s1, s2,i-1,j,dp),f(s1, s2,i -1,j-1,dp),f(s1, s2, i, j - 1,dp)});
}

int editDistance(string& S1, string& S2) {
    int n = S1.size();
    int m = S2.size();
    vector<vector<int>>dp(n+1,vector<int>(m+1,-1));
    return f(S1, S2, n,m,dp);
}





#include <bits/stdc++.h>
int editDistance(string& s1, string& s2) {
    int n = s1.size();
    int m = s2.size();
    vector<vector<int>>dp(n+1,vector<int>(m+1,0));
    for(int j=0;j<=m;j++) dp[0][j] =j;
    for(int i=0;i<=n;i++) dp[i][0]=i;
     
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if (s1[i-1] == s2[j-1])
         dp[i][j]= dp[ i-1][j-1];
          else  //  Delete    Replace    Insert
         dp[i][j] = 1 + min({dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]});
        }
    }
    return dp[n][m];
}








#include <bits/stdc++.h>
int editDistance(string& s1, string& s2) {
    int n = s1.size();
    int m = s2.size();
    vector<int>prev(m+1,0),cur(m+1,0);
    for(int j=0;j<=m;j++) prev[j] =j;
     
    for(int i=1;i<=n;i++){
        cur[0]=i;
        for(int j=1;j<=m;j++){
            if (s1[i-1] == s2[j-1])
              cur[j]= prev[j-1];
            else  //  Delete    Replace    Insert
              cur[j] = 1 + min({prev[j], prev[j - 1], cur[j - 1]});
        }
        prev=cur;
    }
    return prev[m];
}



_____________________________________________________________________________________________________________________________________________________________________________________________

Wildcard Pattern Matching


#include<bits/stdc++.h>
bool f(int i, int j,string&s1, string&s2){

   if(i<0&&j<0) return true; // both over
   if(i<0&&j>=0) return false; // string 1 over and 2 remained
   if(j<0 && i>=0) {
        for(int t=0; t<=i; t++){
            if (s1[t] != '*') {
                return false;
            }
        }
        return true;
    }

   if(s1[i]==s2[j] || s1[i]== '?')  return f(i-1,j-1,s1,s2);
   if(s1[i]== '*' ) return f(i-1,j,s1,s2) || f(i,j-1,s1,s2);  //Matches any sequence of characters
   return false;
}

bool wildcardMatching(string pattern, string text){
   int n= pattern.size();
   int m=text.size();
  return f(n-1,m-1,pattern,text);
}












#include<bits/stdc++.h>
bool f(int i, int j,string&s1, string&s2,vector<vector<int>>dp){

   if(i<0&&j<0) return true; // both over
   if(i<0&&j>=0) return false; // string 1 over and 2 remained
   if(j<0 && i>=0) {
        for(int t=0; t<=i; t++){
            if (s1[t] != '*') {
                return false;
            }
        }
        return true;
    }
    if(dp[i][j]!=-1) return dp[i][j];

   if(s1[i]==s2[j] || s1[i]== '?')  return dp[i][j]= f(i-1,j-1,s1,s2,dp);
   if(s1[i]== '*' ) return dp[i][j]= f(i-1,j,s1,s2,dp) || f(i,j-1,s1,s2,dp);  //Matches any sequence of characters
   return false;
}

bool wildcardMatching(string pattern, string text){
   int n= pattern.size();
   int m=text.size();
   vector<vector<int>>dp(n,vector<int>(m,-1));
  return f(n-1,m-1,pattern,text,dp);
}








#include<bits/stdc++.h>
bool f(int i, int j,string&s1, string&s2,vector<vector<int>>dp){

   if(i==0 && j==0) return true; // both over
   if(i==0 && j>0) return false; // string 1 over and 2 remained
   if(j==0 && i>0) {
        for(int t=1; t<=i; t++){
            if (s1[t-1] != '*') {
                return false;
            }
        }
        return true;
    }
    if(dp[i][j]!=-1) return dp[i][j];

   if(s1[i-1]==s2[j-1] || s1[i-1]== '?')  return dp[i][j]= f(i-1,j-1,s1,s2,dp);
   if(s1[i-1]== '*' ) return dp[i][j]= f(i-1,j,s1,s2,dp) || f(i,j-1,s1,s2,dp);  //Matches any sequence of characters
   return false;
}

bool wildcardMatching(string pattern, string text){
   int n= pattern.size();
   int m=text.size();
   vector<vector<int>>dp(n+1,vector<int>(m+1,-1));
  return f(n,m,pattern,text,dp);
}













#include<bits/stdc++.h>
bool wildcardMatching(string s1, string s2){
   int n= s1.size();
   int m=s2.size();
   vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));

  dp[0][0]=true;
  for(int j=1;j<=m;j++) dp[0][j]=false;  // string 1 over and 2 remained

  for(int i=1;i<=n;i++){
        bool flag=true;
        for(int t=1; t<=i; t++){
            if (s1[t-1] != '*') {
                flag=false;
                break;
            }
        }
        dp[i][0] = flag;
  }


   for(int i=1;i<=n;i++){
       for(int j=1;j<=m;j++){
              if(s1[i-1] == s2[j-1]  ||  s1[i-1] == '?')   dp[i][j]= dp[i-1][j-1];
             else if(s1 [i-1] == '*' )  dp[i][j] = dp[i-1][j] |  dp[i][j-1];  //Matches any sequence of characters
             else dp[i][j]=false;
        }
    }
   return dp[n][m];
   }










#include<bits/stdc++.h>
bool wildcardMatching(string s1, string s2){
   int n= s1.size();
   int m=s2.size();
   vector<bool>prev(m+1,false),cur(m+1,false);
   prev[0]=true;
  for(int j=1;j<=m;j++) prev[j]=false;  // string 1 over and 2 remained

   for(int i=1;i<=n;i++){
 // cur is current row/s column
 // and that cur's 0th row has to be assigned everytime
         bool flag=true;
         for(int t=1; t<=i; t++){
            if (s1[t-1] != '*') {
                flag=false;
                break;
            }
        }
        cur[0] = flag;
       for(int j=1;j<=m;j++){
              if(s1[i-1] == s2[j-1]  ||  s1[i-1] == '?')   cur[j]= prev[j-1];
             else if(s1 [i-1] == '*' )  cur[j] = prev[j] |  cur[j-1];  //Matches any sequence of characters
             else cur[j]=false;
        }
        prev=cur;
    }
   return prev[m];
   }









_____________________________________________________________________________________________________________________________________________________________________




class Solution {
public:
    bool f(int i, int j, int k, string &s1, string &s2, string &s3) {
        if (i < 0 && j < 0 && k < 0) return true;
        if (k < 0) return false; // string 1 over and 2 remained

        if (i >= 0 && j >= 0 && k >= 0 && s1[i] == s3[k] && s2[j] == s3[k]) 
            return f(i - 1, j, k - 1, s1, s2, s3) || f(i, j - 1, k - 1, s1, s2, s3);
        else if (i >= 0 && k >= 0 && s1[i] == s3[k]) 
            return f(i - 1, j, k - 1, s1, s2, s3);
        else if (j >= 0 && k >= 0 && s2[j] == s3[k]) 
            return f(i, j - 1, k - 1, s1, s2, s3);
        else
            return false;
    }

    bool isInterleave(string s1, string s2, string s3) {
        int n = s1.size();
        int m = s2.size();
        int N = s3.size();

        if (n + m != N) return false;

        return f(n - 1, m - 1, N - 1, s1, s2, s3);
    }
};
























class Solution {
public:
    bool rec(string s1,string s2,string s3,int i,int j,int k,vector<vector<int>>&dp){
        if(k==s3.size()&&i==s1.size()&&j==s2.size())return true;
        if(i>s1.size()||j>s2.size())return false;
        if(dp[i][j]!=-1)return dp[i][j];
        if(s3[k]==s2[j]&&s3[k]==s1[i]){
            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp)||rec(s1,s2,s3,i,j+1,k+1,dp);
        }
        else if(s1[i]==s3[k]){
            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp);
        }
        else if(s3[k]==s2[j]){
            return dp[i][j]= rec(s1,s2,s3,i,j+1,k+1,dp);
        }
        else{
            return dp[i][j]= false;
        }
    }
    bool isInterleave(string s1, string s2, string s3) {
        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,-1)));
        return rec(s1,s2,s3,0,0,0,dp);
    }
};















class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,0)));
        if(s3.size()!=s1.size()+s2.size()){
            return false;
        }
        for(int i=s1.size();i>=0;i--){
            for(int j=s2.size();j>=0;j--){
                int k=i+j;
                if(i==s1.size()&&j==s2.size()){
                    dp[i][j]=1;
                }
                else if(s3[k]==s2[j]&&s3[k]==s1[i]){
                    dp[i][j]= dp[i+1][j]||dp[i][j+1];
                }
                else if(s1[i]==s3[k]){
                    dp[i][j]= dp[i+1][j];
                }
                else if(s3[k]==s2[j]){
                    dp[i][j]= dp[i][j+1];
                }
                else{
                    dp[i][j]= false;
                }  
            }
        }
        return dp[0][0];
    }
};











class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        vector<int>cur(s2.size()+1,0),prev(s2.size()+1,0);
        if(s3.size()!=s1.size()+s2.size()){
            return false;
        }
        for(int i=s1.size();i>=0;i--){
            for(int j=s2.size();j>=0;j--){
                int k=i+j;
                if(i==s1.size()&&j==s2.size()){
                    cur[j]=1;
                }
                else if(s3[k]==s2[j]&&s3[k]==s1[i]){
                    cur[j]= prev[j]||cur[j+1];
                }
                else if(s1[i]==s3[k]){
                    cur[j]= prev[j];
                }
                else if(s3[k]==s2[j]){
                    cur[j]= cur[j+1];
                }
                else{
                    cur[j]= false;
                }  
            }
            prev=cur;
        }
        return cur[0];
    }
};
