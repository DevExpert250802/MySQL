Problem statement  


You are given a string 'STR'. The string contains [a-z] [A-Z] [0-9] [special characters]. You have to find the reverse of the string.



#include <bits/stdc++.h> 
string reverseString(string str)
{
	int start=0;
	int end=str.size()-1;
	while(start<end){
		swap(str[start++],str[end--]);
	}
	return str;
}






/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






Problem statement


You are given a string 'S'. Your task is to check whether the string is palindrome or not. For checking palindrome, consider alphabets and numbers only and ignore the symbols and whitespaces.

Note :  String 'S' is NOT case sensitive.

Example :  Let S = “c1 O$d@eeD o1c”.  If we ignore the special characters, whitespaces and convert all uppercase letters to lowercase, we get S = “c1odeedo1c”, which is a palindrome. Hence, the given string is also a palindrome.






#include <bits/stdc++.h> 

bool isValidChar(char ch){
  if((ch >='a' && ch<= 'z') ||(ch >= '0' && ch<= '9')) return true;
  return false;
}


bool isUpperCase(char ch){
  if (ch >= 'A' && ch<= 'Z') return true;
  return false;
}


void toLowerCase(string&s){
  for (int i=0;i<s.length();i++){
    if (isUpperCase(s[i])) {
      s[i] = s[i] + 32;
    }
  }
}


bool checkPalindrome(string s){
  toLowerCase(s);
  bool isPalindrome = true;

  int i=0 ;
  int j=s.size()-1;

  while(i<j){
    if(isValidChar(s[i]) && isValidChar(s[j])){
      if(s[i++]==s[j--]) continue;
      else {
        isPalindrome = false;
        break;
      }
    }
    if (!isValidChar(s[i]))i++;
    if (!isValidChar(s[j]))j--;
  }
  return isPalindrome;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






Problem statement : You are given a string 'str' of length 'N'.Your task is to reverse the original string word by word.

There can be multiple spaces between two words and there can be leading or trailing spaces but in the output reversed string you need to put a single space between two words, and your reversed string should not contain leading or trailing spaces.

Example :If the given input string is "Welcome to Coding Ninjas", then you should return "Ninjas Coding to Welcome" as the reversed string has only a single space between two words and there is no leading or trailing space.







#include <bits/stdc++.h>
string reverseString(string &str){
    stack<string>st;
    string ans="";
    for(int i=0;i<str.length(); i++){
    if(str[i] == ' ') continue;
       string word ="";
       while(i<str.length() && str[i]!=' '){
           word+=str[i];
           i++;
       }
        st.push(word);
    }
     while(!st.empty()){
        ans += st.top();
        st.pop();
        if (!st.empty())
            ans +=' ';
    } 
    return ans;
}







///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////









Count And Say




#include <bits/stdc++.h> 
string countAndSay(int n) {
    if(n==1)return "1";
    if(n==2)return "11";
    string s="11";
    for(int i=3;i<=n;i++){
        s+="$";
	int len=s.length();
        int cnt=1;
        string temp="";
        for(int j=1;j<len;j++){
            if(s[j] != s[j - 1]) {
                temp =temp+to_string(cnt);
	        temp +=s[j-1];
	        cnt=1;
	      }
	    else cnt++;
        }
	s=temp;
    }
	return s;
}
















/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Shuffle Two Strings   ( This code will work for distinct characters )




Problem statement
You are given three strings “A”, “B” and “C”. Your task is to check whether “C” is formed by an interleaving of A and B. C is said to be interleaving “A” and “B”, if the length of “C” is equal to the sum of the length of A and length of B, all the characters of “A” and “B” are present in “C”, and the order of all these characters remains the same in all three strings.





#include <bits/stdc++.h> 
bool isInterleave(string a, string b, string c) {
    int l1 = a.size();
    int l2 = b.size();
    int lr = c.size();
    if (lr != l1 + l2) return false;
    
    int i = 0, j = 0, k = 0;
    while (k < lr) {
        if (i < l1 && a[i] == c[k]) {
            i++;
        } else if (j < l2 && b[j] == c[k]) {
            j++;
        } else {
            return false;
        }
        k++;
    }
    return true;
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




Rotate String





Given two strings s and goal, return true if and only if s1 can become s2 after some number of shifts on s1.
A shift on s1 consists of moving the leftmost character of s1 to the rightmost position.
For example, if s1 = "abcde", then it will be "bcdea" after one shift.






    bool rotateString(string s, string goal) {
        queue<char> q1,q2;
        int i;
        if(s.length()!=goal.length())
        return false;
        for(i=0;i<s.length();i++){
            q1.push(s[i]);
            q2.push(goal[i]);
        }
        for(i=0;i<s.length();i++){
            char temp=q1.front();
            q1.pop();
            q1.push(temp);
            if(q1==q2)
            return true;
        }
        return false;
    }












    bool rotateString(string s, string goal) {
        // If the lengths are different, return false
        if (s.size() != goal.size()) {
            return false;
        }

        string concatenated = goal + goal;
        int i = 0;
        int j = 0;
        int n = s.size();
        int m = concatenated.size();

        while (i < m) {
            if (concatenated[i] == s[j]) {
                j++;
                i++;
                if (j == n) {
                    return true;
                }
            } 
            else {
                if (j != 0) {
                    i=i-j+1;
                    j = 0;
                } else {
                    i++;
                }
            }
        }

        return false;
    }

















    bool rotateString(string s1, string s2) {
        if(s1.length()!=s2.length())return false;
        string s3 = s1 + s1;
        return s3.find(s2)!=string::npos;
    }








////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Problem statement
You are given a string ‘S’ of length ‘N’. You have to return all the characters in the string that are duplicated and their frequency.

Example:-
N = 5
S = ‘GEEK’

ANSWER:- The answer should be [(‘E’,2)] because ‘E’ is the only character that is duplicated and has frequency 2.





#include <bits/stdc++.h> 
vector<pair<char,int>> duplicate_char(string s, int n){
    vector<pair<char,int>>ans;
    map<char,int>mp;
    for(int i=0;i<n;i++){
        mp[s[i]]++;
    }
    for(auto it:mp){
        if (it.second > 1) {
          pair<char, int> temp(it.first, it.second);
          ans.push_back(temp);
        }
    }
    return ans;   
}






